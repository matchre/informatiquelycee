<!doctype html>
<!-- Auteur : David Roche @davR74130 -->
<html lang="fr">
	<head>
		<meta charset="utf-8">
		<title>Le traitement de données structurées</title>
		<link rel="stylesheet" href="css/css/vendor/bootstrap.min.css">
		<link rel="stylesheet" href="css/css/flat-ui.min.css">
		<link rel="stylesheet" href="highlight/styles/tomorrow-night.css">
		<link rel="stylesheet" href="css/style.css">
		<script src="highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
    <script src="./css/js/vendor/jquery.min.js"></script>
    <script src="./css/js/flat-ui.min.js"></script>
	</head>
	<body>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">NSI première</span>
					<span class="navbar-brand">Le traitement de données structurées</span>
        </div>
      </div>
    </nav>
    <div class="container act">
		<p>
			Après avoir découvert le format CSV, nous allons maintenant, à l'aide de Python, apprendre à effectuer des traitements sur ces données.
		</p>
		<p>
			Pour traiter des données, nous allons utiliser la bibliothèque Python Pandas. Une bibliothèque Python permet de rajouter des fonctionnalités par rapport au langage de base. La bibliothèque Pandas est donc très utilisée pour tout ce qui touche au traitement des données.
		</p>
		<p>
			Pour nos premiers pas avec Pandas, nous allons utiliser des données très simples au format CSV : ces données sont contenues dans le fichier <a href="asset/ident_virgule.csv">ident_virgule.csv</a>.
		</p>
		<h4>À faire vous-même 1</h4>
		<p>
			Après avoir téléchargé le fichier <a href="asset/ident_virgule.csv">ident_virgule.csv</a>, placez-le dans le dossier de votre choix (par exemple dans un dossier nommé "NSI_pandas")
		</p>
		<hr />
		<h4>À faire vous-même 2</h4>
		<p>
			Dans la partie "Éditeur de texte" de Spyder, saisissez le code Python suivant :
		</p>
		<pre><code class="python">
import pandas
iden=pandas.read_csv("ident_virgule.csv")
		</code></pre>
		<p>
			Une fois le code saisi, enregistrer le fichier contenant ce code dans le même répertoire que le fichier "ident_virgule.csv"
		</p>
		<hr />
		<p>
			Le code ci-dessus est très simple :
		</p>
		<ul>
			<li>
				Avec la première ligne, nous importons la bibliothèque pandas afin de pouvoir l'utiliser
			</li>
			<li>
				À la deuxième ligne, nous créons une variable "iden" qui va contenir les données présentes dans le fichier "ident_virgule.csv"
			</li>
		</ul>
		<h4>À faire vous-même 3</h4>
		<p>
			Exécutez le programme que vous venez de saisir. Placez ensuite le curseur de la souris dans la console de spyder juste à côté d'un "In [X]" (avec X égal à 1, 2, 3..., selon les cas, dans l'exemple ci-dessous nous avons "In [3]").
			Tapez alors "iden"
		</p>
		<p>
			Vous devriez voir apparaitre les données contenues dans la variable "iden" rangées sous la forme d'un tableau, un peu comme ce que nous obtenions en ouvrant le fichier "ident_virgule.csv" avec un tableur.
		</p>
		<div class="centrer">
		<img src="img/iden.png" />
		</div>
		<hr />
		<p>
			Vous avez peut-être remarqué qu'une colonne a été ajoutée par rapport à ce que nous obtenions avec le tableur :
		</p>
		<div class="centrer">
		<img src="img/idenb.png" />
		</div>
		<p>
			Les nombres présents dans cette colonne sont appelés des index. Chaque ligne du tableau a un index (première ligne : index 0, deuxième ligne index 1...)
		<p>
			ATTENTION : les index commencent à 0 et pas à 1
		</p>
		<p>
			Les colonnes possèdes également des index, dans notre exemple ces index correspondent au "nom" (index de la première colonne), au "prenom" (index de la deuxième colonne) et à "date_naissance" (index de la troisième colonne)
		</p>
		<p>
			En résumé : les lignes possèdent des index (0,1,2..), les colonnes possèdent aussi des index ("nom", "prenom",...)
		</p>
		<p>
			Il est possible de récupérer certaines données du tableau, par exemple, certaines lignes, certaines colonnes ou bien encore des valeurs uniques.
			Pour cela, il suffit d'utiliser l'instruction "loc" avec les index des lignes et les index des colonnes. Le principe de fonctionnement de "loc" est relativement simple puisque l'on aura une instruction de la forme "loc[index_ligne,index_colonne]"
		</p>
		<h4>À faire vous-même 4</h4>
		<p>
			Testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
iden=pandas.read_csv("ident_virgule.csv")
info=iden.loc[1,'prenom']
		</code></pre>
		<p>
			Vérifiez que la variable "info" contient bien le prénom "christophe"
		</p>
		<hr />
		<h4>À faire vous-même 5</h4>
		<p>
			Modifiez le programme du "À faire vous-même 4" pour que la variable info contienne "12/06/1978"
		</p>
		<hr />
		<p>
			Il est possible de récupérer plusieurs toutes les lignes d'une colonne, il suffit de remplacer la partie "index_ligne" de "loc" par ":"
		</p>
		<h4>À faire vous-même 6</h4>
		<p>
			Testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
iden=pandas.read_csv("ident_virgule.csv")
info=iden.loc[:,'nom']
		</code></pre>
		<p>
			Vérifiez que la variable "info" contient bien toutes les données de la colonne d'index "nom", autrement dit, tous les noms
		</p>
		<hr />
		<p>
			Il est possible de récupérer toutes les colonnes d'une ligne particulière, cette fois en remplaçant la partie "index_colonne" de "loc" par ":"
		</p>
		<h4>À faire vous-même 7</h4>
		<p>
			Testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
iden=pandas.read_csv("ident_virgule.csv")
info=iden.loc[2,:]
		</code></pre>
		<p>
			Vérifiez que la variable "info" contient bien toutes les données de la dernière ligne (index 2)
		</p>
		<hr />
		<p>
			Il est aussi possible de récupérer seulement certaines lignes et certaines colonnes en utilisant la notation suivante : loc[[index_ligne_1,index_ligne_2,...],[index_colonne_1,index_colonne_2,...]]
		</p>
		<h4>À faire vous-même 8</h4>
		<p>
			Testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
iden=pandas.read_csv("ident_virgule.csv")
info=iden.loc[[0,1],['nom','date_naissance']]
		</code></pre>
		<p>
			Vérifiez que la variable "info" contient bien un tableau avec uniquement les colonnes "nom" et "date_naissance" de la première ligne (index 0) et de la deuxième ligne (index 1).
		</p>
		<hr />
		<p>
			Afin d'avoir des exemples plus complexes à traiter, dans la suite, nous allons travailler sur les données contenues dans le fichier <a href="asset/villes_virgule.csv">ville_virgule.csv</a>.
		</p>
		<h4>À faire vous-même 9</h4>
		<p>
			Testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
info_villes=pandas.read_csv("villes_virgule.csv")
		</code></pre>
		<p>
			Vérifiez que la variable "info_villes" contient bien les données contenues dans le fichier <a href="asset/villes_virgule.csv">ville_virgule.csv</a>.
		</p>
		<p>
			Comme vous pouvez le constater, il manque des données dans le tableau qui s'affiche dans la console spyder (les données manquantes sont symbolisées par des ...), en effet, le tableau contient trop données pour qu'il soit entièrement affiché dans la console spyder.
			Heureusement, il existe une solution :
		</p>
		<p>
			Dans spyder, dans la fenêtre située juste au-dessus de la console, vous allez trouver un onglet "Explorateur de variables".
			Cliquez sur cet onglet, vous devriez alors obtenir ceci :
		</p>
		<div class="centrer">
		<img src="img/info_villes.png" />
		</div>
		<p>
			Double-cliquez sur "info_villes" et vous devriez 	alors voir apparaitre une nouvelle fenêtre qui contiendra un tableau avec l'ensemble des données.
		</p>
		<hr />
		<p>
			En explorant le tableau, vous devriez, notamment dans les colonnes l'altitude mini et maxi, voir apparaitre un étrange "nan" pour les dernières villes du tableau. "nan" signifie "not a number", ici, cela veut tout simplement dire que certaines données sont manquantes.
		</p>
		<p>
			Nous allons maintenant introduire des conditions dans la sélection des villes. Imaginez par exemple que vous désirez obtenir un tableau contenant toutes les villes qui ont une altitude minimum supérieure à 1500 m :
		</p>
		<h4>À faire vous-même 10</h4>
		<p>
			Analysez et testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
info_villes=pandas.read_csv("villes_virgule.csv")
nom_alt=info_villes.loc[info_villes["alt_min"]>1500,["nom","alt_min"]]
		</code></pre>
		<hr />
		<p>
			Dans le "loc", l'expression "info_villes["alt_min"]>1500" est bien avant la virgule, elle concerne donc les index des lignes du tableau. On sélectionnera uniquement les lignes qui auront la valeur du descripteur "alt_min" supérieure à 1500.
			Nous allons donc bien sélectionner les villes qui ont une altitude minimum supérieure à 1500 m
		</p>
		<h4>À faire vous-même 11</h4>
		<p>
			En vous inspirant de ce qui a été fait au "À faire vous-même 10", écrivez un programme qui permettra d'avoir les villes qui ont une densité d'habitant inférieure à 50 (dans le tableau ainsi créé, on aura 3 colonnes : le nom de la ville, la densité de la population et l'altitude minimum)
		</p>
		<hr />
		<p>
			Il est possible de combiner plusieurs facteurs de sélection en utilisant un "et"("&") ou un "ou"("|").
		</p>
		<h4>À faire vous-même 12</h4>
		<p>
			Analysez et testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
info_villes=pandas.read_csv("villes_virgule.csv")
nom_alt=info_villes.loc[(info_villes["alt_min"]>1500) & (info_villes["dens"]>50),["nom","dens","alt_min"]]
		</code></pre>
		<p>
			Vous devriez constater qu'il y a, en France, une seule ville avec une densité de population supérieure à 50 et une altitude minimum supérieure à 1500 m.
		</p>
		<hr />
		<p>
			Il est aussi possible d'effectuer des calculs sur des colonnes, par exemple des moyennes. Il suffit d'utiliser l'instruction "mean" pour effectuer une moyenne :
		</p>
		<h4>À faire vous-même 13</h4>
		<p>
			Analysez et testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
info_villes=pandas.read_csv("villes_virgule.csv")
moyenne_alt_min=info_villes.loc[:,"alt_min"].mean()
		</code></pre>
		<p>
			Vous devriez constater que l'altitude minimum moyenne est de 193 m en France. Je rappelle que dans "loc[:,"alt_min"]" le ":" signifie que l'on considère toutes les lignes du tableau. De plus le "alt_min" que le calcul
			de la moyenne porte bien sur les données du descripteur "alt_min".
		</p>
		<hr />
		<h4>À faire vous-même 14</h4>
		<p>
			Écrivez un programme permettant de calculer le nombre moyen d'habitants en 2012
		</p>
		<hr />
		<p>
			Pour l'instant nous avons calculé une moyenne sur l'ensemble des lignes, il est aussi possible d'imposer une condition sur les lignes qui seront utilisées pour le calcul.
		</p>
		<h4>À faire vous-même 15</h4>
		<p>
			Analysez et testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
info_villes=pandas.read_csv("villes_virgule.csv")
nbe_hab=info_villes.loc[info_villes["alt_min"]>1500,"nb_hab_2012"].mean()
print(nbe_hab)
		</code></pre>
		<p>
			Vous devriez constater que les villes ayant une altitude minimum supérieure à 1500 m avaient en moyenne 350 habitants en 2012.
		</p>
		<hr />
		<p>
			Il est aussi possible de trier le tableau en fonction des valeurs d'un descripteur. Il suffit d'utiliser l'instruction "sort_values"
		</p>
		<h4>À faire vous-même 16</h4>
		<p>
			Analysez et testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
info_villes=pandas.read_csv("villes_virgule.csv")
tri_alt_min=info_villes.sort_values(by=["alt_min"])
		</code></pre>
		<p>
			Vous devriez obtenir un nouveau tableau de données "tri_alt_min" trié dans l'ordre croissant des altitudes minimums. Quelle est la ville ayant l'altitude minimum la plus faible de France ?
		</p>
		<hr />
		<p>
			Il est aussi possible de trier par ordre décroissant en ajoutant "ascending=False" :
		</p>
		<h4>À faire vous-même 17</h4>
		<p>
			Analysez et testez le programme suivant :
		</p>
		<pre><code class="python">
import pandas
info_villes=pandas.read_csv("villes_virgule.csv")
tri_alt_min=info_villes.sort_values(by=["alt_min"], ascending=False)
		</code></pre>
		<p>
			Quelle est la ville ayant l'altitude minimum la plus importante de France ?
		</p>
		<hr />
		<h4>À faire vous-même 18</h4>
		<p>
			Écrivez un programme permettant de répondre à la question suivante : quelle est la ville ayant la densité de population la plus forte ?
		</p>
		<hr />
		<p>
			Il est possible de fusionner 2 tableaux de données qui ont une colonne commune :
		</p>
		<p>
			Afin de travailler sur cette fusion, nous allons travailler avec 2 fichiers au format CSV : <a href="asset/fiches_client.csv" target="_blank">fiches_client.csv</a> et <a href="fiches_com.csv" target="_blank">fiches_com.csv</a>.
		</p>
		<h4>À faire vous-même 19</h4>
		<p>
			Après avoir téléchargé les 2 fichiers ci-dessus, testez le code suivant :
		</p>
		<pre><code class="python">
import pandas
client=pandas.read_csv("fiches_client.csv")
commande=pandas.read_csv("fiches_com.csv")
		</code></pre>
		<p>
			Utilisez l'explorateur de variables de Spyder afin d'afficher le contenu des variables "client" et "commande"
		</p>
		<hr />
		<p>
			Vous devriez normalement obtenir pour "client" :
		</p>
		<div class="centrer">
			<img src="img/nsi_prem_traitCSV_1.png" />
		</div>
		<p>
			et pour "commande" :
		</p>
		<div class="centrer">
			<img src="img/nsi_prem_traitCSV_2.png" />
		</div>
		<p>
			Rien de bien complexe, nous avons un tableau qui référence les clients (nom, prénom, ville), chaque client possède un numéro de client. Le deuxième tableau référence des commandes :
			pour chaque commande, nous avons un numéro de commande, une date et le numéro du client qui a passé la commande, ce numéro de client correspond évidemment au numéro de client que l'on trouve dans le premier tableau.
		</p>
		<p>
			Sachant que nous avons deux colonnes contenant les mêmes types d'information (numéros de client), nous allons pouvoir fusionner les deux tableaux en un seul :
		</p>
		<h4>À faire vous-même 20</h4>
		<p>
			Testez le code suivant :
		</p>
		<pre><code class="python">
import pandas
client=pandas.read_csv("fiches_client.csv")
commande=pandas.read_csv("fiches_com.csv")
cl_com=pandas.merge(client, commande)
		</code></pre>
		<p>
			Utilisez l'explorateur de variables de Spyder afin d'afficher le contenu de la variable "cl_com"
		</p>
		<hr />
		<p>
			Vous devriez obtenir ceci :
		</p>
		<div class="centrer">
			<img src="img/nsi_prem_traitCSV_3.png" />
		</div>
		<p>
			Prenons l'exemple de Mme Julie Gabriaux qui habite à Bordeaux (n° de client 2454) et de la commande effectuée le 02/02/2012 par le client ayant le n° 2454 (commande n° 45). La cliente qui a passé cette commande n° 45 est bien Mme Gabriaux, nous avons une ligne dans notre tableau "cl-com" :
		</p>
		<div class="centrer">
			<img src="img/nsi_prem_traitCSV_4.png" />
		</div>
		<p>
			Nous avons bien fusionné les 2 tableaux "client" et "commande" en un seul tableau "cl_com" qui regroupe les informations pour chaque commande. Quand on effectue ce genre de fusion, on dit souvent que l'on effectue une jointure.
		</p>
		<p>
			Il faut prendre garde à l'ordre des arguments de la fonction "merge" :
		</p>
		<h4>À faire vous-même 21</h4>
		<p>
			Testez le code suivant :
		</p>
		<pre><code class="python">
import pandas
client=pandas.read_csv("fiches_client.csv")
commande=pandas.read_csv("fiches_com.csv")
com_cl=pandas.merge(commande, client)
		</code></pre>
		<p>
			Utilisez l'explorateur de variables de Spyder afin d'afficher le contenu de la variable "com_cl"
		</p>
		<hr />
		<p>
			Vous devriez obtenir ceci :
		</p>
		<div class="centrer">
			<img src="img/nsi_prem_traitCSV_5.png" />
		</div>
		<p>
			Comme vous pouvez le constater, l'ordre des colonnes est différent. Il faudra donc être attentif à l'ordre des paramètres de la fonction "merge".
		</p>
		<p>
			Remarque : On trouve Mme Ila Neufville sur 2 lignes, car elle a passé 2 commandes.
		</p>
		<h4>À faire vous-même 22</h4>
		<p>
			Vous avez peut-être remarqué que Mme Élodie Gaulin (n° de client 895) bien que présente dans le tableau "client", est absente du tableau "com_cl" (ou "cl_com"). Pourquoi d'après vous ?
		</p>
		<hr />
		<h4>À faire vous-même 23</h4>
		<p>
			De la même manière, aucun trace de la commande n° 1324 du 01/02/2017 dans le tableau "com_cl" (ou "cl_com"), pourquoi d'après vous ?
		</p>
		<hr />
		<p>
			Comme nous venons de le voir ci-dessus, il faut que l'élément qui permet la jointure (ici un numéro de client) soit présent dans les 2 tableaux : dans nos exemples vous avez sans doute remarqué que :
		</p>
		<ul>
			<li>
				Mme Gaulin n'a pas passé de commande, son numéro de client est absent du tableau "commande", d'où son absence du tableau "com_cl" (ou "cl_com"). À noter que nous avons 2 autres clientes qui n'ont jamais passé de commande.
			</li>
			<li>
				Le client qui a passé la commande n°1324 (n° client 4444) est absent du tableau "client", d'où, ici aussi, son absence du tableau "com_cl" (ou "cl_com")
			</li>
		</ul>
		</div>
</html>
