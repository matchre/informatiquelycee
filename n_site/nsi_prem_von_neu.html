<!doctype html>
<!-- Auteur : David Roche @davR74130 -->
<html lang="fr">
	<head>
		<meta charset="utf-8">
		<title>Modèle d'architecture de von Neumann</title>
		<link rel="stylesheet" href="css/css/vendor/bootstrap.min.css">
		<link rel="stylesheet" href="css/css/flat-ui.min.css">
		<link rel="stylesheet" href="highlight/styles/tomorrow-night.css">
		<link rel="stylesheet" href="css/style.css">
		<script src="highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
    <script src="./css/js/vendor/jquery.min.js"></script>
    <script src="./css/js/flat-ui.min.js"></script>
	</head>
	<body>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">NSI première</span>
					<span class="navbar-brand">Modèle d'architecture de von Neumann</span>
        </div>
      </div>
    </nav>
    <div class="container act">
			<p>
				On entend souvent dire qu'"un ordinateur utilise uniquement des "1" et des "0"". Cette affirmation mérite d'être précisée.
			</p>
			<p>
				À la base de la plupart des composants d'un ordinateur, on retrouve le transistor. Ce composant électronique a été inventé fin 1947 par les Américains John Bardeen, William Shockley
				et Walter Brattain. L'invention du transistor a été un immense progrès, mais les premiers ordinateurs sont antérieurs à cette invention. En effet, ces premiers ordinateurs,
				par exemple le Colossus qui date de 1943, étaient conçus à base de tubes électroniques (on parle aussi de tubes à vide) qui, bien que beaucoup plus gros et beaucoup moins fiable que les transistors fonctionnent sur le
				même principe que ce dernier.
			</p>
			<div class="centrer">
				<img src="img/transistor.png" alt="transistor"/>
				<figcaption>un transistor</figcaption>
			</div>
			<div class="centrer">
				<img src="img/tube.jpeg" alt="tube électronique"/>
				<figcaption>un tube électronique</figcaption>
			</div>
			<p>
				Autre aspect historique qu'il est important de préciser : on ne trouve plus, depuis quelque temps déjà, de transistors en tant que composant électronique discret (comme le transistor de la photo ci-dessus). Dans un ordinateur, les transistors sont regroupés au sein de ce que l'on appelle
				des circuits intégrés. Dans un circuit intégré, les transistors sont gravés sur des plaques de silicium, les connexions entre les millions de transistors qui composent un circuit intégré sont, elles aussi, gravées directement dans le silicium. Les processus mis en jeu lors de ces gravures dépassent
				largement le cadre de ce cours, si ce sujet vous intéresse, je vous invite à visionner cette vidéo : <a href="https://www.youtube.com/watch?v=NFr-WyytNfo" target="_blank">https://www.youtube.com/watch?v=NFr-WyytNfo</a>
			</p>
			<div class="centrer">
				<img src="img/ci.jpg" alt="circuit intégré"/>
				<figcaption>un circuit intégré</figcaption>
			</div>
			<p>
				Il n'est pas question de nous pencher en détail sur le fonctionnement d'un transistor, mais vous devez tout de même savoir que dans un ordinateur les transistors se comportent
				comme des interrupteurs : soit le transistor laisse passer le courant électrique (interrupteur fermé), soit il ne le laisse pas passer (interrupteur ouvert).
				Et c'est tout, il n'y a pas d'autre état possible pour un transistor dans un ordinateur : le courant passe ou le courant ne passe pas. Globalement l'ordinateur fonctionne
				uniquement avec deux états. On parle d'un état "haut" et d'un état "bas". On symbolise souvent l'état "haut" par le chiffre "1" et l'état "bas" par le chiffre "0", mais il faut bien avoir conscience
				qu'il n'y a pas dans un ordinateur des "petits 1" ou des "petits 0" qui se "baladent", c'est juste une histoire de "courant qui passe" ou de "courant qui ne passe pas". On travaille donc uniquement avec 2 chiffres,
				voilà pourquoi un ordinateur travaille en base 2 (en binaire) et non pas en base 10 comme dans la vie courante.
			</p>
			<p>
				Le transistor est l'élément de base des circuits logiques. Un circuit logique permet de réaliser une opération booléenne. Ces opérations booléennes sont directement liées à l'algèbre de Boole
				(Georges Boole, mathématicien Britanique 1815-1864). L'étude de l'algèbre de Boole dépasse le cadre de ce cours, vous devez juste savoir qu'un circuit logique prend en entrée
				un ou des signaux électriques (chaque entrée est dans un état "haut" (symbolisé par un "1") ou à un état "bas" (symbolisé par un "0")) et donne en sortie un ou des signaux électriques (chaque sortie est aussi dans un état "haut" ou à un état "bas").
				Il existe deux catégories de circuit logique :
			</p>
			<ul>
				<li>
					les circuits combinatoires (les états en sortie dépendent uniquement des états en entrée)
				</li>
				<li>
					les circuits séquentiels (les états en sortie dépendent des états en entrée ainsi que du temps et des états antérieurs)
				</li>
			</ul>
			<p>
				Dans la suite nous nous intéresserons principalement aux circuits combinatoires.
			</p>
			<p>
				Le plus simple des circuits combinatoires est la porte "NON" ("NOT" en anglais) qui inverse l'état en entrée : si l'entrée de la porte est dans un état "bas" alors
				la sortie sera dans un état "haut" et vice versa. Si on symbolise l'état "haut" par un "1" et l'état "bas" pour un "0", on peut obtenir ce que l'on appelle la table de vérité
				de la porte "NON" :
			</p>
			<table>
        <tr>
            <td width=100px>E (Entrée)</td>
            <td width=100px>S (Sortie)</td>
        </tr>
				<tr>
            <td>1</td>
            <td>0</td>
        </tr>
				<tr>
            <td>0</td>
            <td>1</td>
        </tr>
				</table>
				<br />
				<p>
					La porte "NON" est symbolisée par le schéma suivant :
				</p>
				<div class="centrer">
					<img src="img/porte_NOT.png" alt="porte NON"/>
					<figcaption>porte "NON"</figcaption>
				</div>
				<p>
					La porte "OU" a deux entrées (E1 et E2) et une sortie S
				</p>
				<div class="centrer">
					<img src="img/porte_OR.png" alt="porte OU"/>
					<figcaption>porte "OU"</figcaption>
				</div>
				<p>
					Table de vérité porte "OU" :
				</p>
				<table>
	        <tr>
	            <td width=100px>E1</td>
							<td width=100px>E2</td>
	            <td width=100px>S</td>
	        </tr>
					<tr>
	            <td>0</td>
	            <td>0</td>
							<td>0</td>
	        </tr>
					<tr>
	            <td>0</td>
	            <td>1</td>
							<td>1</td>
	        </tr>
					<tr>
	            <td>1</td>
	            <td>0</td>
							<td>1</td>
	        </tr>
					<tr>
	            <td>1</td>
	            <td>1</td>
							<td>1</td>
	        </tr>
					</table>
					<br />
					<p>
						La porte "ET" ("AND") a deux entrées (E1 et E2) et une sortie S
					</p>
					<div class="centrer">
						<img src="img/porte_AND.png" alt="porte OU"/>
						<figcaption>porte "ET"</figcaption>
					</div>
					<p>
						Table de vérité porte "ET" :
					</p>
					<table>
						<tr>
								<td width=100px>E1</td>
								<td width=100px>E2</td>
								<td width=100px>S</td>
						</tr>
						<tr>
								<td>0</td>
								<td>0</td>
								<td>0</td>
						</tr>
						<tr>
								<td>0</td>
								<td>1</td>
								<td>0</td>
						</tr>
						<tr>
								<td>1</td>
								<td>0</td>
								<td>0</td>
						</tr>
						<tr>
								<td>1</td>
								<td>1</td>
								<td>1</td>
						</tr>
						</table>
						<br />
						<p>
							La porte "OU EXCLUSIF" ("XOR") a deux entrées (E1 et E2) et une sortie S
						</p>
						<div class="centrer">
							<img src="img/porte_XOR.png" alt="porte OU EXCLUSIF"/>
							<figcaption>porte "OU EXCLUSIF"</figcaption>
						</div>
						<p>
							Table de vérité porte "XOR" :
						</p>
						<table>
							<tr>
									<td width=100px>E1</td>
									<td width=100px>E2</td>
									<td width=100px>S</td>
							</tr>
							<tr>
									<td>0</td>
									<td>0</td>
									<td>0</td>
							</tr>
							<tr>
									<td>0</td>
									<td>1</td>
									<td>1</td>
							</tr>
							<tr>
									<td>1</td>
									<td>0</td>
									<td>1</td>
							</tr>
							<tr>
									<td>1</td>
									<td>1</td>
									<td>0</td>
							</tr>
							</table>
							<br />
			<p>
				En combinant les portes logiques, on obtient des circuits plus complexes. Par exemple en combinant 2 portes "OU EXCLUSIF", 2 portes "ET" et une porte "OU" on obtient un additionneur :
			</p>
			<div class="centrer">
				<img src="img/porte_ADD.png" alt="Additionneur"/>
				<figcaption>Additionneur</figcaption>
			</div>
			<p>
				Comme son nom l'indique, l'additionneur permet d'additionner 2 bits (E1 et E2) en tenant compte de la retenue entrante ("Cin" "carry in" en anglais). En sortie on obtient le résultat de l'addition (S) et la retenue sortante ("Cout").
			</p>
			<h4>À faire vous-même 1</h4>
			<p>
				Établir la table de vérité de l'additionneur en complétant le tableau ci-dessous
			</p>
			<table>
				<tr>
						<td width=100px>E1</td>
						<td width=100px>E2</td>
						<td width=100px>Cin</td>
						<td width=100px>Cout</td>
						<td width=100px>S</td>
				</tr>
				<tr>
						<td>0</td>
						<td>0</td>
						<td>0</td>
						<td>0</td>
						<td>0</td>
				</tr>
				<tr>
						<td>0</td>
						<td>0</td>
						<td>1</td>
						<td>0</td>
						<td>1</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>1</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>0</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>1</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>0</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>1</td>
					<td></td>
					<td></td>
				</tr>
				</table>
				<br />
			<hr />
			<p>
				En combinant plusieurs fois le type de circuit décrit ci-dessus, on obtient des additionneurs capables d'additionner des nombres sur X bits.
			</p>
			<p>
				Une chose est très importante à bien comprendre : à la base nous avons le transistor, une combinaison de transistor (sous forme de circuit intégré) permet d'obtenir des
				circuits logiques, la combinaison de circuits logiques permet d'obtenir des circuits plus complexes (exemple : l'additionneur), et ainsi de suite...
			</p>
			<p>
				Au sommet de cet édifice (on pourrait parler de poupée russe), nous allons trouver la mémoire vive (RAM) et le microprocesseur (CPU).
			</p>
			<h4>La mémoire vive RAM (Random Acess Memory)</h4>
			<p>
				La mémoire vive permet de stocker des données et des programmes. Comme nous l'avons vu, l'ordinateur utilise uniquement 2 états, la mémoire va donc stocker les données sous forme de bits (0 ou 1), mais encore une fois, il ne faut pas s'imaginer que la mémoire est pleine de "petit 0" et de "petit 1", ce sont des "états électriques" qui sont stockés dans cette mémoire.
			</p>
			<p>
				La mémoire ne gère pas les bits 1 par 1, mais 8 par 8, la mémoire gère donc des octets (rappel : 1 octet = 8 bits)
			</p>
			<p>
				On peut se représenter la mémoire comme une série de cellules, chaque cellule étant capable de stocker 1 octet. Chacune de ces cellules possède une adresse. Les opérations sur la mémoire sont de 2 types : lecture / écriture.
				Une opération de lecture consiste à aller lire l'octet situé à l'adresse mémoire XXXXX (ces adresses mémoire étant bien évidemment codées en binaire) et une opération d'écriture consiste à écrire un octet donné à l'adresse mémoire YYYYY. Cette notion d'adresse mémoire est fondamentale, nous aurons l'occasion de revenir dessus un peu plus loin.
			</p>
			<p>
				Toujours sur l'aspect technologique, 1 bit d'une cellule est l'association d'un transistor et d'un condensateur. Un condensateur est un composant électronique qui peut être soit chargé (on stocke alors un "1"), soit déchargé (on stocke alors un "0").
				Un condensateur n'est pas capable de conserver sa charge pendant très longtemps, il doit donc être alimenté électriquement parlant afin de conserver cette charge. Voilà pourquoi
				la mémoire vive est une mémoire volatile : toutes les données présentes en mémoire sont perdues en cas de coupure de courant. Pour conserver les données une fois l'ordinateur éteint, il faut faire appel à d'autres types de mémoire : les mémoires de stockage.
				Le disque dur est aujourd'hui la mémoire de stockage la plus utilisé (au moins dans les usages "familiaux"). Un disque dur n'a pas besoin d'alimentation électrique pour conserver les données.
			</p>
			<p>
				Pour terminer sur cet aspect technologique, il faut noter que l'on trouve aussi des mémoires vives qui stockent l'information grâce à un circuit dit de type "bascule". Ce circuit est une combinaison de plusieurs portes logiques.
			</p>
			<div class="centrer">
				<img src="img/bascule.png" alt="circuit de type bascule"/>
				<figcaption>circuit de type bascule, permet de stocker 1 bit</figcaption>
			</div>
			<p>
				Il n'est pas question pour nous d'étudier ce type de circuit, le schéma ci-dessus vous permet juste de vérifier qu'une fois de plus nous avons bien à faire à une combinaison de porte logique.
			</p>
			<h4>Le microprocesseur CPU (Central Processing Unit)</h4>
			<div class="centrer">
				<img src="img/cpu.jpg" alt="microprocesseur"/>
				<figcaption>microprocesseur</figcaption>
			</div>
			<p>
				Le microprocesseur est le "coeur" d'un ordinateur : les instructions sont exécutées au niveau du CPU. Il est schématiquement constitué de 3 parties :
			</p>
			<ul>
				<li>
					les registres permettent de mémoriser de l'information (donnée ou instruction) au sein même du CPU. Leur nombre et leur taille sont variables en fonction du type de microprocesseur. Dans la suite on nommera ces registres R1, R2, R3...
				</li>
				<li>
					L'unité arithmétique et logique (UAL ou ALU en anglais) est chargée de l'exécution de tous les calculs que peut réaliser le microprocesseur. Nous allons retrouver dans cette UAL des circuits comme l'additionneur (voir plus haut)
				</li>
				<li>
					L'unité de commande permet d'exécuter les instructions (les programmes)
				</li>
			</ul>
			<p>
				Arrêtons-nous sur ces instructions aussi appelées "instructions machines". Comme vous le savez déjà, un ordinateur exécute des programmes qui sont des suites d'instructions. Le CPU est incapable d'exécuter directement des programmes écrits, par exemple, en Python. En effet, comme tous les autres constituants d'un ordinateur, le CPU gère uniquement 2 états (toujours
				symbolisés par un "1" et un "0"), les instructions exécutées au niveau du CPU sont donc codées en binaire. L'ensemble des instructions exécutables directement par le microprocesseur constitue ce que l'on appelle le "langage machine".
			</p>
			<p>
				Une instruction machine est une chaîne binaire composée principalement de 2 parties :
			</p>
			<ul>
				<li>
					le champ "code opération" qui indique au processeur le type de traitement à réaliser. Par exemple le code "00100110" donne l'ordre au CPU d'effectuer une multiplication.
				</li>
				<li>
					le champ "opérandes" indique la nature des données sur lesquelles l'opération désignée par le "code opération" doit être effectuée.
				</li>
			</ul>
			<div class="centrer">
				<img src="img/instr_machine.png" alt="instruction machine"/>
				<figcaption>instruction machine</figcaption>
			</div>
			<p>
				Les instructions machines sont relativement basiques (on parle d'instructions de bas niveau), voici quelques exemples :
			</p>
			<ul>
				<li>
					les instructions arithmétiques (addition, soustraction, multiplication...). Par exemple, on peut avoir une instruction qui ressemble à "additionne la valeur contenue dans le registre R1 et le nombre 789 et range le résultat dans le registre R0"
					(l'adresse mémoire est donnée en base 10 pour souci de simplicité, n'oubliez pas qu'en interne elle est codée en binaire)
				</li>
				<li>
					les instructions de transfert de données qui permettent de transférer une donnée d'un registre du CPU vers la mémoire vive et vice versa. Par exemple, on peut avoir une instruction qui ressemble à "prendre la valeur située à l'adresse mémoire 487 et la placer dans la registre R2"
					ou encore "prendre la valeur située dans le registre R1 et la placer à l'adresse mémoire 512"
				</li>
				<li>
					les instructions de rupture de séquence : les instructions machines sont situées en mémoire vive, si, par exemple, l'instruction n°1 est située à l'adresse mémoire 343,
					l'instruction n°2 sera située à l'adresse mémoire 344, l'instruction n°3 sera située à l'adresse mémoire 345... Au cours de l'exécution d'un programme, le CPU passe d'une instruction à une autre en passant d'une adresse mémoire à l'adresse mémoire immédiatement supérieure : après avoir exécuté l'instruction n°2
					(situé à l'adresse mémoire 344), le CPU "va chercher" l'instruction suivante à l'adresse mémoire 344+1=345.  Les instructions de rupture de séquence d'exécution encore appelées instructions de saut ou de branchement permettent d'interrompre
					l'ordre initial sous certaines conditions en passant à une instruction située une adresse mémoire donnée, par exemple, nous pouvons avoir une instruction qui ressemble à cela : imaginons qu'à l'adresse mémoire 354 nous avons l'instruction "si la valeur contenue dans le registre R1 est strictement supérieure à 0 alors exécuter l'instruction située à l'adresse mémoire 4521".
					Si la valeur contenue dans le registre R1 est strictement supérieure à 0 alors la prochaine instruction à exécuter est l'adresse mémoire 4521, dans le contraire, la prochaine instruction à exécuter est à l'adresse mémoire 355.
				</li>
			</ul>
			<p>
				Comme déjà dit, les opérandes désignent les données sur lesquelles le code opération de l'instruction doit être réalisée. Un opérande peut être de 3 natures différentes :
			</p>
			<ol style="color:black;font-family: Verdana,Helvetica, sans-serif;font-size: 16px;">
				<li>
					l'opérande est une valeur immédiate : l'opération est effectuée directement sur la valeur donnée dans l'opérande
				</li>
				<li>
					l'opérande est un registre du CPU : l'opération est effectuée sur la valeur située dans un des registres (R0,R1, R2,...), l'opérande indique de quel registre il s'agit
				</li>
				<li>
					l'opérande est une donnée située en mémoire vive : l'opération est effectuée sur la valeur située en mémoire vive à l'adresse XXXXX. Cette adresse est indiquée dans l'opérande.
				</li>
			</ol>
			<p>
				Quand on considère l'instruction machine : "additionne le nombre 125 et la valeur située dans le registre R2 , range le résultat dans le registre R1", nous avons 2 valeurs : le "nombre 125" (qui est une valeur immédiate, nous sommes dans le cas n°1) et "la valeur située dans le registre R2" (nous sommes dans le cas n°2)
			</p>
			<p>
				Quand on considère l'instruction machine : "prendre la valeur située dans le registre R1 et la placer à l'adresse mémoire 512", nous avons 2 valeurs : "à l'adresse mémoire 512" (nous sommes dans le cas n°3) et "la valeur située dans le registre R1" (nous sommes toujours dans le cas n°2)
			</p>
			<p>
				Évidemment le microprocesseur est incapable d'interpréter la phrase "additionne le nombre 125 et la valeur située dans le registre R2 , range le résultat dans le registre R1" tout cela doit être codé sous forme binaire.
			</p>
			<p>
				Un programme en langage machine est donc une suite très très longue de "1" et de "0", ce qui vous en conviendrez est quelque peu rébarbatif à programmer : sur les dizaines de milliers de "1" et de "0" qui composent un programme en langage machine de taille modeste, une seule erreur, et votre programme ne fonctionne pas...imaginer la difficulté pour retrouver l'erreur !
				Bref programmer en langage machine est extrêmement difficile, pour pallier cette difficulté, les informaticiens ont remplacé les codes binaires abscons par des symboles mnémoniques (plus facile à retenir qu'une suite de "1" et de "0"). Nous avons toujours des instructions machines du genre "additionne le nombre 125 et la valeur située dans le registre R2 , range le résultat dans le registre R1", mais au lieu d'écrire "11100010100000100001000001111101",
				nous pourrons écrire "ADD R1,R2,#125". Dans les 2 cas, la signification est identique : "additionne le nombre 125 et la valeur située dans le registre R2 , range le résultat dans le registre R1".
			</p>
			<p>
				Le processeur est uniquement capable d'interpréter le langage machine, un programme appelé "assembleur" assure donc le passage de "ADD R1,R2,#125" à "11100010100000100001000001111101". Par extension, on dit que l'on programme en assembleur quand on écrit des programmes avec ces symboles mnémoniques à la place de suites de "0" et de "1". Aujourd'hui plus personne n'écrit de programme directement en langage machine, en revanche l'écriture de programme en assembleur est encore chose relativement courante.
			</p>
			<p>
				Il n'est pas question d'apprendre à programmer en assembleur dans ce cours, mais voici tout de même quelques exemples d'instructions en assembleur :
			</p>
			<pre><code class="plaintext">
LDR R1,78
			</code></pre>
			<p>
				Place la valeur stockée à l'adresse mémoire 78 dans le registre R1 (par souci de simplification, nous continuons à utiliser des adresses mémoire codées en base 10)
			</p>
			<pre><code class="plaintext">
STR R3,125
			</code></pre>
			<p>
				Place la valeur stockée dans le registre R3 en mémoire vive à l'adresse 125
			</p>
			<pre><code class="plaintext">
ADD R1,R0,#128
			</code></pre>
			<p>
				Additionne le nombre 128 (une valeur immédiate est identifiée grâce au symbole #) et la valeur stockée dans le registre R0, place le résultat dans le registre R1
			</p>
			<pre><code class="plaintext">
ADD R0,R1,R2
			</code></pre>
			<p>
				 Additionne la valeur stockée dans le registre R1 et la valeur stockée dans le registre R2, place le résultat dans le registre R0
			</p>
			<pre><code class="plaintext">
SUB R1,R0,#128
			</code></pre>
			<p>
				 Soustrait le nombre 128 de la valeur stockée dans le registre R0, place le résultat dans le registre R1
			</p>
			<pre><code class="plaintext">
SUB R0,R1,R2
			</code></pre>
			<p>
				 Soustrait la valeur stockée dans le registre R2 de la valeur stockée dans le registre R1, place le résultat dans le registre R0
			</p>
			<pre><code class="plaintext">
MOV R1, #23
			</code></pre>
			<p>
				 Place le nombre 23 dans le registre R1
			</p>
			<pre><code class="plaintext">
MOV R0, R3
			</code></pre>
			<p>
				 Place la valeur stockée dans le registre R3 dans le registre R0
			</p>
			<pre><code class="plaintext">
B 45
			</code></pre>
			<p>
				 Nous avons une structure de rupture de séquence, la prochaine instruction à exécuter se situe en mémoire vive à l'adresse 45
			</p>
			<pre><code class="plaintext">
CMP R0, #23
			</code></pre>
			<p>
				 Compare la valeur stockée dans le registre R0 et le nombre 23. Cette instruction CMP doit précéder une instruction de branchement conditionnel BEQ, BNE, BGT, BLT (voir ci-dessous)
			</p>
			<pre><code class="plaintext">
CMP R0, R1
			</code></pre>
			<p>
				 Compare la valeur stockée dans le registre R0 et la valeur stockée dans le registre R1.
			</p>
			<pre><code class="plaintext">
CMP R0, #23
BEQ 78
			</code></pre>
			<p>
				 La prochaine instruction à exécuter se situe à l'adresse mémoire 78 si la valeur stockée dans le registre R0 est égale à 23
			</p>
			<pre><code class="plaintext">
CMP R0, #23
BNE 78
			</code></pre>
			<p>
				 La prochaine instruction à exécuter se situe à l'adresse mémoire 78 si la valeur stockée dans le registre R0 n'est pas égale à 23
			</p>
			<pre><code class="plaintext">
CMP R0, #23
BGT 78
			</code></pre>
			<p>
				 La prochaine instruction à exécuter se situe à l'adresse mémoire 78 si la valeur stockée dans le registre R0 est plus grand que 23
			</p>
			<pre><code class="plaintext">
CMP R0, #23
BLT 78
			</code></pre>
			<p>
				 La prochaine instruction à exécuter se situe à l'adresse mémoire 78 si la valeur stockée dans le registre R0 est plus petit que 23
			</p>
			<pre><code class="plaintext">
HALT
			</code></pre>
			<p>
				 Arrête l'exécution du programme
			</p>
			<hr />
			<p>
				Encore une fois, il n'est pas question d'apprendre à programmer en assembleur, les instructions ci-dessus sont uniquement des exemples.
			</p>
			<h4>À faire vous-même 2</h4>
			<p>
				Expliquez brièvement (sur le même modèle que les exemples ci-dessus), les instructions suivantes :
			</p>
			<pre><code class="plaintext">
ADD R0, R1, #42
			</code></pre>
			<pre><code class="plaintext">
LDR R5,98
			</code></pre>
			<pre><code class="plaintext">
CMP R4, #18
BGT 77
			</code></pre>
			<pre><code class="plaintext">
STR R0,15
			</code></pre>
			<pre><code class="plaintext">
B 100
			</code></pre>
			<hr />
			<h4>À faire vous-même 3</h4>
			<p>
				Écrire les instructions en assembleur correspondant aux phrases suivantes :
			</p>
			<ul>
				<li>
					Additionne la valeur stockée dans le registre R0 et la valeur stockée dans le registre R1, le résultat est stocké dans le registre R5
				</li>
				<li>
					Place la valeur stockée à l'adresse mémoire 878 dans le registre R0
				</li>
				<li>
					Place le contenu du registre R0 en mémoire vive à l'adresse 124
				</li>
				<li>
					la prochaine instruction à exécuter se situe en mémoire vive à l'adresse 478
				</li>
				<p>
					Si la valeur stockée dans le registre R0 est égale 42 alors la prochaine instruction à exécuter se situe à l'adresse mémoire 85
				</p>
			</ul>
			<hr />
			<p>
				En faite, les instructions assembleur B, BEQ, BNE, BGT et BLT n'utilisent pas directement l'adresse mémoire de la prochaine instruction à exécuter, mais des "labels". Un label correspond à une adresse en mémoire vive (c'est l'assembleur qui fera la traduction "label"->"adresse mémoire"). L'utilisation d'un label évite donc d'avoir à manipuler des adresses mémoires en binaire ou en hexadécimale.
				Voici un exemple qui montre comment utiliser un label :
			</p>
			<pre><code class="plaintext">
   CMP R4, #18
   BGT monLabel
   MOV R0,#14
   HALT
monLabel:
   MOV R0,#18
   HALT
			</code></pre>
			<p>
				Dans l'exemple ci-dessus, nous avons choisi "monLabel" comme nom de label. La ligne "MOV R0,#18" a pour label "monLabel" car elle est située juste après la ligne "monLabel:". Concrètement, voici ce qui se passe avec ce programme :
				si la valeur stockée dans le registre R4 est supérieure à 18 on place le nombre 18 dans le registre R0 sinon on place le nombre 14 dans le registre R0. ATTENTION : la présence du "HALT" juste après la ligne "MOV R0,#14" est indispensable, car sinon, la ligne "MOV R0,#18" sera aussi exécutée (même si la valeur stockée dans le registre R4 est inférieure à 18 )
			</p>
			<h4>À faire vous-même 4</h4>
			<p>
				Voici un programme Python très simple :
			</p>
			<pre><code class="python">
x = 4
y = 8
if x == 10:
	y = 9
else :
	x=x+1
z=6
			</code></pre>
			<p>
				et voici maintenant voici son équivalent en assembleur :
			</p>
			<pre><code class="plaintext">
   MOV R0, #4
   STR R0,30
   MOV R0, #8
   STR R0,75
   LDR R0,30
   CMP R0, #10
   BNE else
   MOV R0, #9
   STR R0,75
   B endif
else:
   LDR R0,30
   ADD R0, R0, #1
   STR R0,30
endif:
   MOV R0, #6
   STR R0,23
   HALT
			</code></pre>
			<p>
				Après avoir analysé très attentivement le programme en assembleur ci-dessus, vous essaierez d'établir une correspondance entre les lignes du programme en Python et les lignes du programme en assembleur. À quoi sert la ligne "B endif" ? À quoi correspondent les adresses mémoires 23, 75 et 30 ?
			</p>
			<p>
				Comme vous avez pu le constater dans les exemples ci-dessus, les données et les instructions sont stockées en mémoire vive, les données et les instructions se partagent la mémoire vive (il n'y a pas une mémoire pour les instructions et une mémoire différente pour les données). C'est John von Neumann (mathématicien et physicien américano-hongrois 1903-1957)
				qui a eu l'idée en 1945 d'utiliser une structure de stockage unique pour les données et les instructions, voilà pourquoi on parle d'architecture de von Neumann.
				Encore aujourd'hui, tous les ordinateurs fonctionnent sur ce principe défini par von Neumann. À noter que John von Neumann était un véritable génie "touche à tout" puisqu'il a laissé son nom dans l'histoire de la mécanique quantique, dans l'histoire de la théorie des ensembles...et comme nous venons de le voir, dans l'histoire de l'informatique. Il a aussi participé à l'élaboration de la bombe atomique américaine lors de la 2e guerre mondiale (projet Manhattan).
			</p>
		</div>
	</body>
</html>
