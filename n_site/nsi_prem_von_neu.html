<!doctype html>
<!-- Auteur : David Roche @davR74130 -->
<html lang="fr">
	<head>
		<meta charset="utf-8">
		<title>Modèle d'architecture de von Neumann</title>
		<link rel="stylesheet" href="css/css/vendor/bootstrap.min.css">
		<link rel="stylesheet" href="css/css/flat-ui.min.css">
		<link rel="stylesheet" href="highlight/styles/tomorrow-night.css">
		<link rel="stylesheet" href="css/style.css">
		<script src="highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
    <script src="./css/js/vendor/jquery.min.js"></script>
    <script src="./css/js/flat-ui.min.js"></script>
	</head>
	<body>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">NSI première</span>
					<span class="navbar-brand">Modèle d'architecture de von Neumann</span>
        </div>
      </div>
    </nav>
    <div class="container act">
			<p>
				On entend souvent dire qu'"un ordinateur utilise uniquement des "1" et des "0"". Cette affirmation mérite d'être précisée.
			</p>
			<p>
				À la base de la plupart des composants d'un ordinateur, on retrouve le transistor. Ce composant électronique a été inventé fin 1947 par les Américains John Bardeen, William Shockley
				et Walter Brattain. L'invention du transistor a été un immense progrès, mais les premiers ordinateurs sont antérieurs à cette invention. En effet, ces premiers ordinateurs,
				par exemple le Colossus qui date de 1943, étaient conçus à base de tubes électroniques (on parle aussi de tubes à vide) qui, bien que beaucoup plus gros et beaucoup moins fiable que les transistors fonctionnent sur le
				même principe que ce dernier.
			</p>
			<div class="centrer">
				<img src="img/transistor.png" alt="transistor"/>
				<figcaption>un transistor</figcaption>
			</div>
			<div class="centrer">
				<img src="img/tube.jpeg" alt="tube électronique"/>
				<figcaption>un tube électronique</figcaption>
			</div>
			<p>
				Autre aspect historique qu'il est important de préciser : on ne trouve plus, depuis quelque temps déjà, de transistors en tant que composant électronique discret (comme le transistor de la photo ci-dessus). Dans un ordinateur, les transistors sont regroupés au sein de ce que l'on appelle
				des circuits intégrés. Dans un circuit intégré, les transistors sont gravés sur des plaques de silicium, les connexions entre les millions de transistors qui composent un circuit intégré sont, elles aussi, gravées directement dans le silicium. Les processus mis en jeu lors de ces gravures dépassent
				largement le cadre de ce cours, si ce sujet vous intéresse, je vous invite à visionner cette vidéo : <a href="https://www.youtube.com/watch?v=NFr-WyytNfo" target="_blank">https://www.youtube.com/watch?v=NFr-WyytNfo</a>
			</p>
			<div class="centrer">
				<img src="img/ci.jpg" alt="circuit intégré"/>
				<figcaption>un circuit intégré</figcaption>
			</div>
			<p>
				Il n'est pas question de nous pencher en détail sur le fonctionnement d'un transistor, mais vous devez tout de même savoir que dans un ordinateur les transistors se comportent
				comme des interrupteurs : soit le transistor laisse passer le courant électrique (interrupteur fermé), soit il ne le laisse pas passer (interrupteur ouvert).
				Et c'est tout, il n'y a pas d'autre état possible pour un transistor dans un ordinateur : le courant passe ou le courant ne passe pas. Globalement l'ordinateur fonctionne
				uniquement avec deux états. On parle d'un état "haut" et d'un état "bas". On symbolise souvent l'état "haut" par le chiffre "1" et l'état "bas" par le chiffre "0", mais il faut bien avoir conscience
				qu'il n'y a pas dans un ordinateur des "petits 1" ou des "petits 0" qui se "baladent", c'est juste une histoire de "courant qui passe" ou de "courant qui ne passe pas". On travaille donc uniquement avec 2 chiffres,
				voilà pourquoi un ordinateur travaille en base 2 (en binaire) et non pas en base 10 comme dans la vie courante.
			</p>
			<p>
				Le transistor est l'élément de base des circuits logiques. Un circuit logique permet de réaliser une opération booléenne. Ces opérations booléennes sont directement liées à l'algèbre de Boole
				(Georges Boole, mathématicien Britanique 1815-1864). L'étude de l'algèbre de Boole dépasse le cadre de ce cours, vous devez juste savoir qu'un circuit logique prend en entrée
				un ou des signaux électriques (chaque entrée est dans un état "haut" (symbolisé par un "1") ou à un état "bas" (symbolisé par un "0")) et donne en sortie un ou des signaux électriques (chaque sortie est aussi dans un état "haut" ou à un état "bas").
				Il existe deux catégories de circuit logique :
			</p>
			<ul>
				<li>
					les circuits combinatoires (les états en sortie dépendent uniquement des états en entrée)
				</li>
				<li>
					les circuits séquentiels (les états en sortie dépendent des états en entrée ainsi que du temps et des états antérieurs)
				</li>
			</ul>
			<p>
				Dans la suite nous nous intéresserons principalement aux circuits combinatoires.
			</p>
			<p>
				Le plus simple des circuits combinatoires est la porte "NON" ("NOT" en anglais) qui inverse l'état en entrée : si l'entrée de la porte est dans un état "bas" alors
				la sortie sera dans un état "haut" et vice versa. Si on symbolise l'état "haut" par un "1" et l'état "bas" pour un "0", on peut obtenir ce que l'on appelle la table de vérité
				de la porte "NON" :
			</p>
			<table>
        <tr>
            <td width=100px>E (Entrée)</td>
            <td width=100px>S (Sortie)</td>
        </tr>
				<tr>
            <td>1</td>
            <td>0</td>
        </tr>
				<tr>
            <td>0</td>
            <td>1</td>
        </tr>
				</table>
				<br />
				<p>
					La porte "NON" est symbolisée par le schéma suivant :
				</p>
				<div class="centrer">
					<img src="img/porte_NOT.png" alt="porte NON"/>
					<figcaption>porte "NON"</figcaption>
				</div>
				<p>
					La porte "OU" a deux entrées (E1 et E2) et une sortie S
				</p>
				<div class="centrer">
					<img src="img/porte_OR.png" alt="porte OU"/>
					<figcaption>porte "OU"</figcaption>
				</div>
				<p>
					Table de vérité porte "OU" :
				</p>
				<table>
	        <tr>
	            <td width=100px>E1</td>
							<td width=100px>E2</td>
	            <td width=100px>S</td>
	        </tr>
					<tr>
	            <td>0</td>
	            <td>0</td>
							<td>0</td>
	        </tr>
					<tr>
	            <td>0</td>
	            <td>1</td>
							<td>1</td>
	        </tr>
					<tr>
	            <td>1</td>
	            <td>0</td>
							<td>1</td>
	        </tr>
					<tr>
	            <td>1</td>
	            <td>1</td>
							<td>1</td>
	        </tr>
					</table>
					<br />
					<p>
						La porte "ET" ("AND") a deux entrées (E1 et E2) et une sortie S
					</p>
					<div class="centrer">
						<img src="img/porte_AND.png" alt="porte OU"/>
						<figcaption>porte "ET"</figcaption>
					</div>
					<p>
						Table de vérité porte "ET" :
					</p>
					<table>
						<tr>
								<td width=100px>E1</td>
								<td width=100px>E2</td>
								<td width=100px>S</td>
						</tr>
						<tr>
								<td>0</td>
								<td>0</td>
								<td>0</td>
						</tr>
						<tr>
								<td>0</td>
								<td>1</td>
								<td>0</td>
						</tr>
						<tr>
								<td>1</td>
								<td>0</td>
								<td>0</td>
						</tr>
						<tr>
								<td>1</td>
								<td>1</td>
								<td>1</td>
						</tr>
						</table>
						<br />
						<p>
							La porte "OU EXCLUSIF" ("XOR") a deux entrées (E1 et E2) et une sortie S
						</p>
						<div class="centrer">
							<img src="img/porte_XOR.png" alt="porte OU EXCLUSIF"/>
							<figcaption>porte "OU EXCLUSIF"</figcaption>
						</div>
						<p>
							Table de vérité porte "XOR" :
						</p>
						<table>
							<tr>
									<td width=100px>E1</td>
									<td width=100px>E2</td>
									<td width=100px>S</td>
							</tr>
							<tr>
									<td>0</td>
									<td>0</td>
									<td>0</td>
							</tr>
							<tr>
									<td>0</td>
									<td>1</td>
									<td>1</td>
							</tr>
							<tr>
									<td>1</td>
									<td>0</td>
									<td>1</td>
							</tr>
							<tr>
									<td>1</td>
									<td>1</td>
									<td>0</td>
							</tr>
							</table>
							<br />
			<p>
				En combinant les portes logiques, on obtient des circuits plus complexes. Par exemple en combinant 2 portes "OU EXCLUSIF", 2 portes "ET" et une porte "OU" on obtient un additionneur :
			</p>
			<div class="centrer">
				<img src="img/porte_ADD.png" alt="Additionneur"/>
				<figcaption>Additionneur</figcaption>
			</div>
			<p>
				Comme son nom l'indique, l'additionneur permet d'additionner 2 bits (E1 et E2) en tenant compte de la retenue entrante ("Cin" "carry in" en anglais). En sortie on obtient le résultat de l'addition (S) et la retenue sortante ("Cout").
			</p>
			<h4>À faire vous-même 1</h4>
			<p>
				Établir la table de vérité de l'additionneur en complétant le tableau ci-dessous
			</p>
			<table>
				<tr>
						<td width=100px>E1</td>
						<td width=100px>E2</td>
						<td width=100px>Cin</td>
						<td width=100px>Cout</td>
						<td width=100px>S</td>
				</tr>
				<tr>
						<td>0</td>
						<td>0</td>
						<td>0</td>
						<td>0</td>
						<td>0</td>
				</tr>
				<tr>
						<td>0</td>
						<td>0</td>
						<td>1</td>
						<td>0</td>
						<td>1</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>0</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>1</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>0</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>1</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>0</td>
					<td></td>
					<td></td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>1</td>
					<td></td>
					<td></td>
				</tr>
				</table>
				<br />
			<hr />
			<p>
				En combinant plusieurs fois le type de circuit décrit ci-dessus, on obtient des additionneurs capables d'additionner des nombres sur X bits.
			</p>
			<p>
				Une chose est très importante à bien comprendre : à la base nous avons le transistor, une combinaison de transistor (sous forme de circuit intégré) permet d'obtenir des
				circuits logiques, la combinaison de circuits logiques permet d'obtenir des circuits plus complexes (exemple : l'additionneur), et ainsi de suite...
			</p>
			<p>
				Au sommet de cet édifice (on pourrait parler de poupée russe), nous allons trouver la mémoire vive (RAM) et le microprocesseur (CPU).
			</p>
			<h4>La mémoire vive RAM (Random Acess Memory)</h4>
			<p>
				La mémoire vive permet de stocker des données et des programmes. Comme nous l'avons vu, l'ordinateur utilise uniquement 2 états, la mémoire va donc stocker les données sous forme de bits (0 ou 1), mais encore une fois, il ne faut pas s'imaginer que la mémoire est pleine de "petit 0" et de "petit 1", ce sont des "états électriques" qui sont stockés dans cette mémoire.
			</p>
			<p>
				La mémoire ne gère pas les bits 1 par 1, mais 8 par 8, la mémoire gère donc des octets (rappel : 1 octet = 8 bits)
			</p>
			<p>
				On peut se représenter la mémoire comme une série de cellules, chaque cellule étant capable de stocker 1 octet. Chacune de ces cellules possède une adresse. Les opérations sur la mémoire sont de 2 types : lecture / écriture.
				Une opération de lecture consiste à aller lire l'octet situé à l'adresse mémoire XXXXX (ces adresses mémoire étant bien évidemment codées en binaire) et une opération d'écriture consiste à écrire un octet donné à l'adresse mémoire YYYYY. Cette notion d'adresse mémoire est fondamentale, nous aurons l'occasion de revenir dessus un peu plus loin.
			</p>
			<p>
				Toujours sur l'aspect technologique, 1 bit d'une cellule est l'association d'un transistor et d'un condensateur. Un condensateur est un composant électronique qui peut être soit chargé (on stocke alors un "1"), soit déchargé (on stocke alors un "0").
				Un condensateur n'est pas capable de conserver sa charge pendant très longtemps, il doit donc être alimenté électriquement parlant afin de conserver cette charge. Voilà pourquoi
				la mémoire vive est une mémoire volatile : toutes les données présentes en mémoire sont perdues en cas de coupure de courant. Pour conserver les données une fois l'ordinateur éteint, il faut faire appel à d'autres types de mémoire : les mémoires de stockage.
				Le disque dur est aujourd'hui la mémoire de stockage la plus utilisé (au moins dans les usages "familiaux"). Un disque dur n'a pas besoin d'alimentation électrique pour conserver les données.
			</p>
			<p>
				Pour terminer sur cet aspect technologique, il faut noter que l'on trouve aussi des mémoires vives qui stockent l'information grâce à un circuit dit de type "bascule". Ce circuit est une combinaison de plusieurs portes logiques.
			</p>
			<div class="centrer">
				<img src="img/bascule.png" alt="circuit de type bascule"/>
				<figcaption>circuit de type bascule, permet de stocker 1 bit</figcaption>
			</div>
			<p>
				Il n'est pas question pour nous d'étudier ce type de circuit, le schéma ci-dessus vous permet juste de vérifier qu'une fois de plus nous avons bien à faire à une combinaison de porte logique.
			</p>
			<h4>Le microprocesseur CPU (Central Processing Unit)</h4>
			<div class="centrer">
				<img src="img/cpu.jpg" alt="microprocesseur"/>
				<figcaption>microprocesseur</figcaption>
			</div>
			<p>
				Le microprocesseur est le "coeur" d'un ordinateur : les instructions sont exécutées au niveau du CPU. Il est schématiquement constitué de 3 parties :
			</p>
			<ul>
				<li>
					les registres permettent de mémoriser de l'information (donnée ou instruction) au sein même du CPU. Leur nombre et leur taille sont variables en fonction du type de microprocesseur. Dans la suite on nommera ces registres R1, R2, R3...
				</li>
				<li>
					L'unité arithmétique et logique (UAL ou ALU en anglais) est chargée de l'exécution de tous les calculs que peut réaliser le microprocesseur. Nous allons retrouver dans cette UAL des circuits comme l'additionneur (voir plus haut)
				</li>
				<li>
					L'unité de commande permet d'exécuter les instructions (les programmes)
				</li>
			</ul>
			<p>
				Arrêtons-nous sur ces instructions aussi appelées "instructions machines". Comme vous le savez déjà, un ordinateur exécute des programmes qui sont des suites d'instructions. Le CPU est incapable d'exécuter directement des programmes écrits, par exemple, en Python. En effet, comme tous les autres constituants d'un ordinateur, le CPU gère uniquement 2 états (toujours
				symbolisés par un "1" et un "0"), les instructions exécutées au niveau du CPU sont donc codées en binaire. L'ensemble des instructions exécutables directement par le microprocesseur constitue ce que l'on appelle le "langage machine".
			</p>
			<p>
				Une instruction machine est une chaîne binaire composée principalement de 2 parties :
			</p>
			<ul>
				<li>
					le champ "code opération" qui indique au processeur le type de traitement à réaliser. Par exemple le code "00100110" donne l'ordre au CPU d'effectuer une multiplication.
				</li>
				<li>
					le champ "opérandes" indique la nature des données sur lesquelles l'opération désignée par le "code opération" doit être effectuée.
				</li>
			</ul>
			<div class="centrer">
				<img src="img/instr_machine.png" alt="instruction machine"/>
				<figcaption>instruction machine</figcaption>
			</div>
			<p>
				Les instructions machines sont relativement basiques (on parle d'instructions de bas niveau), voici quelques exemples :
			</p>
			<ul>
				<li>
					les instructions arithmétiques (addition, soustraction, multiplication...). Par exemple, on peut avoir une instruction qui ressemble à "additionne la valeur contenue dans le registre R1 et la valeur située à l'adresse mémoire 789, range le résultat dans le registre R1"
					(l'adresse mémoire est donnée en base 10 pour souci de simplicité, n'oubliez pas qu'en interne elle est codée en binaire)
				</li>
				<li>
					les instructions de transfert de données qui permettent de transférer une donnée d'un registre du CPU vers la mémoire vive et vice versa. Par exemple, on peut avoir une instruction qui ressemble à "prendre la valeur située à l'adresse mémoire 487 et la placer dans la registre R2"
					ou encore "prendre la valeur située dans le registre R1 et la placer à l'adresse mémoire 512"
				</li>
				<li>
					les instructions de rupture de séquence : les instructions machines sont situées en mémoire vive, si, par exemple, l'instruction n°1 est située à l'adresse mémoire 343,
					l'instruction n°2 sera située à l'adresse mémoire 344, l'instruction n°3 sera située à l'adresse mémoire 345... Au cours de l'exécution d'un programme, le CPU passe d'une instruction à une autre en passant d'une adresse mémoire à l'adresse mémoire immédiatement supérieure : après avoir exécuté l'instruction n°2
					(situé à l'adresse mémoire 344), le CPU "va chercher" l'instruction suivante à l'adresse mémoire 344+1=345.  Les instructions de rupture de séquence d'exécution encore appelées instructions de saut ou de branchement permettent d'interrompre
					l'ordre initial sous certaines conditions en passant à une instruction située une adresse mémoire donnée, par exemple, nous pouvons avoir une instruction qui ressemble à cela : imaginons qu'à l'adresse mémoire 354 nous avons l'instruction "si la valeur contenue dans le registre R1 est strictement supérieure à 0 alors exécuter l'instruction située à l'adresse mémoire 4521".
					Si la valeur contenue dans le registre R1 est strictement supérieure à 0 alors la prochaine instruction à exécuter est l'adresse mémoire 4521, dans le contraire, la prochaine instruction à exécuter est à l'adresse mémoire 355.
				</li>
			</ul>
			<p>
				Comme déjà dit, les opérandes désignent les données sur lesquelles le code opération de l'instruction doit être réalisée. Un opérande peut être de 3 natures différentes :
			</p>
			<ol style="color:black;font-family: Verdana,Helvetica, sans-serif;font-size: 16px;">
				<li>
					l'opérande est une valeur immédiate : l'opération est effectuée directement sur la valeur donnée dans l'opérande
				</li>
				<li>
					l'opérande est un registre du CPU : l'opération est effectuée sur la valeur située dans un des registres (R1, R2,...), l'opérande indique de quel registre il s'agit
				</li>
				<li>
					l'opérande est une donnée située en mémoire vive : l'opération est effectuée sur la valeur située en mémoire vive à l'adresse XXXXX. Cette adresse est indiquée dans l'opérande.
				</li>
			</ol>
			<p>
				Quand on considère l'instruction machine : "additionne la valeur 3 et la valeur située dans le registre R2 , range le résultat dans le registre R2", nous avons 2 valeurs : le "3" (qui est une valeur immédiate, nous sommes dans le cas n°1) et "la valeur située dans le registre R2" (nous sommes dans le cas n°2)
			</p>
			<p>
				Quand on considère l'instruction machine : "additionne la valeur située dans le registre R2 et la valeur située à l'adresse mémoire 789, range le résultat dans le registre R2", nous avons 2 valeurs : "la valeur située à l'adresse mémoire 789" (nous sommes dans le cas n°3) et "la valeur située dans le registre R2" (nous sommes toujours dans le cas n°2)
			</p>
			<p>
				Évidemment le microprocesseur est incapable d'interpréter "additionne la valeur située dans le registre R2 et la valeur située à l'adresse mémoire 789, range le résultat dans le registre R2" tout cela doit être codé sous forme binaire.
			</p>
			<p>
				Un programme en langage machine est donc une suite très très longue de "1" et de "0", ce qui vous en conviendrez est quelque peu rébarbatif à programmer : sur les dizaines de milliers de "1" et de "0" qui composent un programme en langage machine de taille modeste, une seule erreur, et votre programme ne fonctionne pas...imaginer la difficulté pour retrouver l'erreur !
				Bref programmer en langage machine est extrêmement difficile, pour pallier cette difficulté, les informaticiens ont remplacé les codes binaires abscons par des symboles mnémoniques (plus facile à retenir qu'une suite de "1" et de "0"). Nous avons toujours des instructions machines du genre "additionne la valeur 3 et la valeur située dans le registre R2, range le résultat dans le registre R2", mais au lieu d'écrire "0010111100000001",
				nous pourrons écrire "ADD Rg2 R0 R1" (le "Rg2" signifie que l'on utilise 2 registres dans cette opération). Dans les 2 cas, la signification est identique : "additionne la valeur située dans le registre R0 avec la valeur située dans le registre R1 et place le résultat dans le registre R0".
			</p>
			<p>
				Le processeur est uniquement capable d'interpréter le langage machine, un programme appelé "assembleur" assure donc le passage de "ADD Rg2 R0 R1" à "0010111100000001". Par extension, on dit que l'on programme en assembleur quand on écrit des programmes avec ces symboles mnémoniques à la place de suites de "0" et de "1". Aujourd'hui plus personne n'écrit de programme directement en langage machine, en revanche l'écriture de programme en assembleur est encore chose relativement courante.
			</p>
			<p>
				Il n'est pas question d'apprendre à programmer en assembleur dans ce cours, mais voici tout de même quelques exemples d'instructions en assembleur :
			</p>
			<ul>
				<li>
					LOAD D R1 387 : place la valeur stockée à l'adresse mémoire 387 dans le registre R1 (par souci de simplification, nous continuons à utiliser des adresses mémoire codées en base 10), le "D" signifie que le "387" est une adresse en mémoire vive.
				</li>
				<li>
					LOAD Im R1 487 : place le nombre 487 dans le registre R1, le "Im" signifie "Immédiat" : 487 doit être considérée comme un nombre et pas comme une adresse mémoire.
				</li>
				<li>
					STORE D R1 478 : place le contenu du registre R1 en mémoire vive à l'adresse "478"
				</li>
				<li>
					SWAP Rg2 R1 R2 : le contenu du registre R1 et le contenu du registre R2 sont échangés. Comme déjà dit plus haut, le Rg2 signifie que l'on utilise 2 registres dans cette opération
				</li>
				<li>
					ADD Im R0 254 : additionne le nombre 254 (valeur immédiate) et le contenu du registre R0, place le résultat dans le registre R0
				</li>
				<li>
					ADD Im R0 254 : additionne le nombre 254 (valeur immédiate) et le contenu du registre R0, place le résultat dans le registre R0
				</li>
				<li>
					JMP 478 : nous avons une structure de rupture de séquence, la prochaine instruction à exécuter se situe en mémoire vive à l'adresse 478
				</li>
				<li>
					JMPZ 897 : si le contenu du registre R1 est nul alors la prochaine instruction à exécuter se trouve à l'adresse mémoire 897 (sinon l'exécution du programme se continue normalement)
				</li>
			</ul>
			<p>
				Encore une fois, il n'est pas question d'apprendre à programmer en assembleur, les instructions ci-dessus sont uniquement des exemples.
			</p>
			<h4>À faire vous-même 2</h4>
			<p>
				Expliquez brièvement (sur le même modèle que les exemples ci-dessus), les instructions suivantes :
			</p>
			<ul>
				<li>
					ADD Im R1 745
				</li>
				<li>
					STORE D R2 423
				</li>
				<li>
					JMP 8899
				</li>
				<li>
					LOAD D R0 7785
				</li>
				<li>
					ADD Rg2 R1 R2
				</li>
			</ul>
			<hr />
			<h4>À faire vous-même 3</h4>
			<p>
				Écrire les instructions en assembleur correspondant aux phrases suivantes :
			</p>
			<ul>
				<li>
					additionne la valeur stockée dans le registre R0 et la valeur stockée dans le registre R1, le résultat est stocké dans le registre R1
				</li>
				<li>
					place la valeur stockée à l'adresse mémoire 878 dans le registre R0
				</li>
				<li>
					place le contenu du registre R0 en mémoire vive à l'adresse "124"
				</li>
				<li>
					la prochaine instruction à exécuter se situe en mémoire vive à l'adresse 478
				</li>
			</ul>
			<hr />
			<p>
				Comme vous avez pu le constater dans les exemples ci-dessus, les données et les instructions sont stockées en mémoire vive, les données et les instructions se partagent la mémoire vive (il n'y a pas une mémoire pour les instructions et une mémoire différente pour les données). C'est John von Neumann (mathématicien et physicien américano-hongrois 1903-1957)
				qui a eu l'idée en 1945 d'utiliser une structure de stockage unique pour les données et les instructions, voilà pourquoi on parle d'architecture de von Neumann.
				Encore aujourd'hui, tous les ordinateurs fonctionnent sur ce principe défini par von Neumann. À noter que John von Neumann était un véritable génie "touche à tout" puisqu'il a laissé son nom dans l'histoire de la mécanique quantique, dans l'histoire de la théorie des ensembles...et comme nous venons de le voir, dans l'histoire de l'informatique. Il a aussi participé à l'élaboration de la bombe atomique américaine lors de la 2e guerre mondiale (projet Manhattan).
			</p>
		</div>
	</body>
</html>
