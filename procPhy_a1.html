<!doctype html>
<!-- Auteur : David Roche @davR74130 -->
<html lang="fr">
	<head>
		<meta charset="utf-8">
		<title>Faire de la physique (et un peu de maths) avec Processing</title>
		<link rel="stylesheet" href="css/css/vendor/bootstrap.min.css">
		<link rel="stylesheet" href="css/css/flat-ui.min.css">
		<link rel="stylesheet" href="css/style.css">
        <link rel="stylesheet" href="highlight/styles/tomorrow-night.css">
    <script src="highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="./css/js/vendor/jquery.min.js"></script>
    <script src="./css/js/flat-ui.min.js"></script>
    <script src="libProc/processing.min.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
  });
</script>
    <script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-92673245-1', 'auto');
		ga('send', 'pageview');
	</script>
	</head>
	<body>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">Faire de la physique (et un peu de maths) avec Processing</span>
					<span class="navbar-brand">Activité 1</span>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="./Fixed Top Navbar Example for Bootstrap_files/Fixed Top Navbar Example for Bootstrap.html" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Activités <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                <li><a href="./procPhy_a2.html">Activité 2</a></li>
                <li><a href="./procPhy_a3.html">Activité 3</a></li>
                <li><a href="./procPhy_a4.html">Activité 4</a></li>
                <li><a href="./procPhy_a5.html">Activité 5</a></li>
                <li><a href="./procPhy_a6.html">Activité 6</a></li>
              </ul>
            </li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="procPhy_a2.html"><span class="fui-triangle-right-large"></a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
    <div class="container act">
        <p>Cette série d'activités s'inspire de l'excellent livre de Daniel Shiffman, <a href="http://natureofcode.com/" target="_blank">"The Nature of Code"</a> (licence Creative Commons Attribution-NonCommercial 3.0).</p>
        <p>Vous devez avoir des connaissances de base sur les vecteurs (un niveau "classe de seconde" de l'enseignement général devrait suffire). Si nécessaire, vous trouverez des cours de mathématiques en ligne qui abordent ce sujet, comme par exemple <a href="https://www.kartable.fr/seconde/mathematiques/specifique/chapitres-4/les-vecteurs/cours/les-vecteurs/3611" target="_blank">ici</a>.</p>
        <p>Vous devez maîtriser les notions suivantes :</p>
        <ul>
            <li>qu'est-ce qu'un vecteur</li>
            <li>coordonnées d'un vecteur</li>
            <li>norme d'un vecteur</li>
            <li>addition et soustraction de 2 vecteurs</li>
            <li>produit d'un vecteur par un réel</li>
        </ul>
        <p>Pour manipuler les vecteurs, Processing propose la classe "PVector". Voici quelques exemples d'utilisation des méthodes de la classe PVector (un vecteur est un objet (au sens programmation orientée objet) dans Processing) :</p>
        <p>Pour créer un vecteur, il suffit d'écrire :</p>
        <pre><code>
PVector AB;
AB = new PVector(5,15);
        </code></pre>
        <p>Ces 2 lignes vous  permettent de créer un vecteur $\vec{AB}$ de coordonnées $\begin{pmatrix} 5 \\ 15 \end{pmatrix}$</p>
        <p>Si vous ne passez aucun paramètre au constructeur PVector :</p>
        <pre><code>
PVector AB;
AB = new PVector();
        </code></pre>
        <p>par défaut, le vecteur $\vec{AB}$ a pour coordonnées $\begin{pmatrix} 0 \\ 0 \end{pmatrix}$ (vecteur nul $\vec{0}$).</p>
        <p>Il est possible d'obtenir la coordonnée x d'un vecteur $\vec{AB}$ en écrivant "AB.x" (même chose pour la coordonnée y avec "AB.y"). "AB.x" et "AB.y" sont de type float.</p>
        <h4>À faire vous-même 1.1</h4>
        <p>Saisissez et testez ce code</p>
        <pre><code>
PVector AB;
AB = new PVector(5,15);
println("x : "+AB.x+" y : "+AB.y);
        </code></pre>
        <hr>
        <p>La méthode "mag" permet d'obtenir la norme d'un vecteur.</p>
        <h4>À faire vous-même 1.2</h4>
        <p>Saisissez et testez ce code</p>
        <pre><code>
PVector AB;
float normeAB;
AB = new PVector(5,15);
normeAB = AB.mag();
println(normeAB);
        </code></pre>
        <hr>
        <p>La méthode "mult" permet d'avoir le résultat d'un vecteur par un réel. Cette méthode peut s'utiliser de 2 manières différentes :</p>
        <ul>
            <li>"AB.mult(k)" permet d'avoir k$\vec{AB}$. Après cette ligne, le vecteur $\vec{AB}$ a maintenant pour valeur k$\vec{AB}$ (c'est un peu l'équivalent d'un "x=k*x" pour une variable x)</li>
            <li>"CD=PVector.mult(AB,k)" permet d'avoir $\vec{CD}=k\vec{AB}$</li>
        </ul>
        <h4>À faire vous-même 1.3</h4>
        <p>Saisissez et testez ce code</p>
        <pre><code>
PVector AB;
float k=2.0;
AB = new PVector(5,15);
println("Avant => x : "+AB.x+" y : "+AB.y);
AB.mult(k);
println("Après => x : "+AB.x+" y : "+AB.y);
        </code></pre>
        <hr>
        <h4>À faire vous-même 1.4</h4>
        <p>Saisissez et testez ce code</p>
        <pre><code>
PVector AB;
PVector CD;
float k=2.0;
AB = new PVector(5,15);
CD = new PVector();
CD=AB.mult(AB,k);
println("AB => x : "+AB.x+" y : "+AB.y);
println("CD => x : "+CD.x+" y : "+CD.y);
        </code></pre>
        <hr>
        <p>La méthode "add" permet d'additionner 2 vecteurs. Comme pour la méthode "mult", la méthode "add" peut être utilisée de 2 façons :</p>
        <ul>
            <li>"AB.add(CD)" permet d'avoir $\vec{AB}+\vec{CD}$. Après cette ligne, le vecteur $\vec{AB}$ a maintenant pour valeur $\vec{AB}+\vec{CD}$ (c'est un peu l'équivalent d'un "x=y+x" pour une variable x)</li>
            <li>"EF=PVector.add(AB,CD)" permet d'avoir $\vec{EF}=\vec{AB}+\vec{CD}$</li>
        </ul>
        <h4>À faire vous-même 1.5</h4>
        <p>Saisissez et testez ce code</p>
        <pre><code>
PVector AB;
PVector CD;
AB = new PVector(5,15);
CD = new PVector(9,8);
println("AB avant => x : "+AB.x+" y : "+AB.y);
println("CD avant => x : "+CD.x+" y : "+CD.y);
AB.add(CD);
println("AB après => x : "+AB.x+" y : "+AB.y);
println("CD après => x : "+CD.x+" y : "+CD.y);
        </code></pre>
        <hr>
        <h4>À faire vous-même 1.6</h4>
        <p>Saisissez et testez ce code</p>
        <pre><code>
PVector AB;
PVector CD;
PVector EF;
AB = new PVector(5,15);
CD = new PVector(9,8);
EF = new PVector();
println("AB avant => x : "+AB.x+" y : "+AB.y);
println("CD avant => x : "+CD.x+" y : "+CD.y);
println("EF avant => x : "+EF.x+" y : "+EF.y);
EF=PVector.add(AB,CD);
println("AB après => x : "+AB.x+" y : "+AB.y);
println("CD après => x : "+CD.x+" y : "+CD.y);
println("EF après => x : "+EF.x+" y : "+EF.y);
        </code></pre>
        <hr>
        <p>La méthode "sub" permet de soustraire 2 vecteurs, elle s'utilise comme la méthode "add". La relation $\vec{EF}=\vec{AB}-\vec{CD}$ s'écrit :</p>
        <pre><code>
EF = PVector.sub(AB,CD); //avec EF, AB et CD de type PVector
        </code></pre>
        <p>Comme pour la méthode "add", il est aussi possible d'écrire :</p>
        <pre><code>
AB.sub(CD);
        </code></pre>
        <p>La méthode "normalize" permet de normaliser un vecteur (cette notion vous est peut-être inconnue). Soit un vecteur $\vec{AB}$ la normalisation de ce vecteur donnera un vecteur $\vec{u}$ qui aura la même direction et le même sens que $\vec{AB}$ mais qui n'aura pas la même norme. On aura $||\vec{u}||$=1 ($\vec{u}$ est un vecteur unitaire). On aura donc $\vec{AB}=||\vec{AB}||\vec{u}$.</p>
        <h4>À faire vous-même 1.7</h4>
        <p>Saisissez et testez ce code</p>
        <pre><code>
PVector AB;
PVector u;
float normeu;
float normeAB;
AB = new PVector(5,15);
u = new PVector();
AB.normalize(u);
normeu=u.mag();
normeAB=AB.mag();
println("norme de u = "+normeu);
println("norme de AB = "+normeAB);
        </code></pre>
        <h4>À faire vous-même 1.8</h4>
        <p>Créez un programme qui permettra de vérifier que $\vec{AB}$ et $\vec{u}$ (voir ci-dessus) ont bien la même direction (colinéaire) et le même sens</p>
        <hr>
    </div>
	</body>
</html>
